import asyncio
import subprocess
from pathlib import Path

import dns.resolver
from sqlalchemy.ext.asyncio import AsyncSession

from database.models import Site
from settings import VARS

NGINX_MAP_PATH = Path("/etc/nginx/maps/sites.conf")
CNAME_TARGET = f"cname.{VARS['main_domain']}"


def check_cname(custom_domain: str) -> bool:
    """
    Check if a custom domain has a CNAME record pointing to `cname.<main_domain>`.
    """

    try:
        answers = dns.resolver.resolve(custom_domain, "CNAME")
        for rdata in answers:
            target = str(rdata.target).rstrip(".")
            if target.lower() == CNAME_TARGET.lower():
                return True
        return False
    except (
        dns.resolver.NoAnswer,
        dns.resolver.NXDOMAIN,
        dns.resolver.NoNameservers,
        dns.resolver.LifetimeTimeout,
    ):
        return False


async def link_custom_domain(db: AsyncSession, site: Site, custom_domain: str) -> None:
    """
    Link a custom domain to a site.
    """

    custom_domain = custom_domain.lower().strip()

    if site.hostname == custom_domain:
        raise DomainAlreadyLinkedError(
            f"Domain '{custom_domain}' is already linked to this site"
        )

    existing_site = await Site.get_by_hostname(db, custom_domain)
    if existing_site is not None:
        raise DomainAlreadyLinkedError(
            f"Domain '{custom_domain}' is already linked to another site"
        )

    if not check_cname(custom_domain):
        raise CNAMENotFoundError(
            f"CNAME record for '{custom_domain}' must point to '{CNAME_TARGET}'"
        )

    site.hostname = custom_domain
    await db.commit()
    await write_nginx_map(db)


async def unlink_custom_domain(
    db: AsyncSession, site: Site, restore_canonical: str
) -> None:
    """
    Unlink a custom domain from a site and restore canonical hostname.
    """

    site.hostname = restore_canonical
    await db.commit()
    await write_nginx_map(db)


async def write_nginx_map(db: AsyncSession) -> None:
    """
    Write the nginx map configuration file and reload nginx.

    This generates /etc/nginx/maps/sites.conf, see [`nocost/deploy`](https://github.com/no-cost/deploy/blob/master/playbooks/files/etc/nginx/maps/sites.conf).
    """

    sites = await Site.get_all_active(db, Site.hostname.isnot(None))
    main_domain = VARS["main_domain"]
    allowed_domains = VARS["allowed_domains"]

    # hostnames -> site_id
    internal_entries: list[str] = []
    custom_entries: list[str] = []
    for site in sites:
        # internal hosts: {tag}.{domain} permutations
        for domain in allowed_domains:
            internal_entries.append(f"    {site.tag}.{domain}    {site.tag};")
        # custom domain entry
        if not _is_internal_domain(site.hostname):
            custom_entries.append(f"    {site.hostname}    {site.tag};")

    # site_id -> canonical hostname
    canonical_entries: list[str] = []
    for site in sites:
        canonical_entries.append(f"    {site.tag}    {site.hostname};")

    # site_id -> service_type
    type_entries: list[str] = []
    for site in sites:
        type_entries.append(f"    {site.tag}    {site.site_type};")

    config = f"""\
# auto-generated by: site_manager/custom_domains.py:write_nginx_map
# hostnames -> site_id
map $host $site_id {{
    hostnames;

    # internal hosts
{'\n'.join(internal_entries) if internal_entries else "    # (none)"}

    # user domains/CNAMEs
{'\n'.join(custom_entries) if custom_entries else "    # (none)"}

    default "";
}}

# site_id -> canonical hostname
map $site_id $canonical_host {{
{'\n'.join(canonical_entries) if canonical_entries else "    # (none)"}

    default "";
}}

# site_id -> service type
map $site_id $service_type {{
{'\n'.join(type_entries) if type_entries else "    # (none)"}

    default "";
}}
"""

    await asyncio.to_thread(_write_config_and_reload, config)


def _write_config_and_reload(config: str) -> None:
    NGINX_MAP_PATH.write_text(config)

    # do not run nginx -t as nocost can't read nginx conf files
    # for the same reason has to run via systemctl
    subprocess.run(["systemctl", "reload", "nginx"], check=True)


def _is_internal_domain(hostname: str) -> bool:
    return any(hostname.endswith(f".{domain}") for domain in VARS["allowed_domains"])


class CustomDomainError(Exception):
    """Base exception for custom domain operations."""


class CNAMENotFoundError(CustomDomainError):
    """CNAME record not found or doesn't point to the expected target."""


class DomainAlreadyLinkedError(CustomDomainError):
    """Domain is already linked to this or another site."""
