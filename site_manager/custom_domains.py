from pathlib import Path

import dns.resolver
from sqlalchemy.ext.asyncio import AsyncSession

from database.models import Site
from settings import VARS
from site_manager import upgrade_site
from site_manager.tenant_config import update_config
from utils.cmd import run_cmd, run_cmd_as_tenant

NGINX_MAP_PATH = Path("/etc/nginx/maps/sites.conf")
CUSTOM_SERVER_NAMES_PATH = Path("/etc/nginx/snippets/custom-server-names.conf")
CERTBOT_WEBROOT = Path("/var/lib/letsencrypt")
CNAME_TARGET = f"cname.{VARS['main_domain']}"


def check_cname(custom_domain: str) -> bool:
    """Check if a custom domain has a CNAME record pointing to `cname.<main_domain>`"""

    try:
        answers = dns.resolver.resolve(custom_domain, "CNAME")
        for rdata in answers:
            target = str(rdata.target).rstrip(".")
            if target.lower() == CNAME_TARGET.lower():
                return True
        return False
    except (
        dns.resolver.NoAnswer,
        dns.resolver.NXDOMAIN,
        dns.resolver.NoNameservers,
        dns.resolver.LifetimeTimeout,
    ):
        return False


async def link_custom_domain(db: AsyncSession, site: Site, custom_domain: str) -> None:
    """
    Link a custom domain to a site.
    """

    custom_domain = custom_domain.lower().strip()

    if site.hostname == custom_domain:
        raise DomainAlreadyLinkedError(
            f"Domain '{custom_domain}' is already linked to this site"
        )

    existing_site = await Site.get_by_hostname(db, custom_domain)
    if existing_site is not None:
        raise DomainAlreadyLinkedError(
            f"Domain '{custom_domain}' is already linked to another site"
        )

    if not check_cname(custom_domain):
        raise CNAMENotFoundError(
            f"CNAME record for '{custom_domain}' must point to '{CNAME_TARGET}'"
        )

    # obtain TLS certificate before switching hostname, so a failure
    # leaves the site on its old (working) domain
    await _obtain_certificate(custom_domain)

    old_hostname = site.hostname
    site.hostname = custom_domain
    await db.commit()
    await write_nginx_maps(db)
    await rewrite_urls(site, old_hostname)


async def unlink_custom_domain(
    db: AsyncSession, site: Site, restore_canonical: str
) -> None:
    """
    Unlink a custom domain from a site and restore canonical hostname.
    """

    old_hostname = site.hostname
    site.hostname = restore_canonical
    await db.commit()
    await write_nginx_maps(db)
    await _delete_certificate(old_hostname)
    await rewrite_urls(site, old_hostname)


async def write_nginx_maps(db: AsyncSession) -> None:
    """
    Write nginx map config for all tenants and reload nginx.

    generates two files under /etc/nginx/maps/:
    - sites.conf: hostname/site_id/service_type maps
    - custom-server-names.conf: server_name directive for custom domain TLS matching
    """

    # hostnames -> site_id
    internal_entries: list[str] = []
    custom_entries: list[str] = []
    # site_id -> canonical hostname
    canonical_entries: list[str] = []
    # site_id -> service_type
    type_entries: list[str] = []

    async for site in Site.get_all_active(db, Site.hostname.isnot(None)):
        # internal hosts: {tag}.{domain} permutations
        for domain in VARS["allowed_domains"]:
            internal_entries.append(f"    {site.tag}.{domain}    {site.tag};")
        # custom domain entry
        if not _is_internal_domain(site.hostname):
            custom_entries.append(f"    {site.hostname}    {site.tag};")
        canonical_entries.append(f"    {site.tag}    {site.hostname};")
        type_entries.append(f"    {site.tag}    {site.site_type};")

    sites_config = f"""\
# auto-generated by: site_manager/custom_domains.py:write_nginx_map
# hostnames -> site_id
map $host $site_id {{
    hostnames;

    # internal hosts
{"\n".join(internal_entries) if internal_entries else "    # (none)"}

    # user domains/CNAMEs
{"\n".join(custom_entries) if custom_entries else "    # (none)"}

    default "";
}}

# site_id -> canonical hostname
map $site_id $canonical_host {{
{"\n".join(canonical_entries) if canonical_entries else "    # (none)"}

    default "";
}}

# site_id -> service type
map $site_id $service_type {{
{"\n".join(type_entries) if type_entries else "    # (none)"}

    default "";
}}
"""

    # custom domain server_name entries (included in the tenant server block
    # so custom domains pass TLS instead of hitting ssl_reject_handshake)
    custom_hostnames = [e.split()[0] for e in custom_entries]
    server_names_config = (
        "# auto-generated by: site_manager/custom_domains.py:write_nginx_map\n"
    )
    if custom_hostnames:
        server_names_config += f"server_name {' '.join(custom_hostnames)};\n"

    await _write_configs_and_reload(sites_config, server_names_config)


async def rewrite_urls(site: Site, old_hostname: str) -> None:
    await update_config(site, {"url": f"https://{site.hostname}"})

    tenant_root = Path(VARS["paths"]["tenants"]["root"]) / site.tag
    tenant_user = f"tenant_{site.tag}"

    if site.site_type == "wordpress":
        await run_cmd_as_tenant(
            tenant_user,
            f"wp search-replace 'https://{old_hostname}' 'https://{site.hostname}' --all-tables --precise",
            cwd=tenant_root / "public",
        )

    await upgrade_site(site)


class CustomDomainError(Exception):
    """Base exception for custom domain operations."""


class CNAMENotFoundError(CustomDomainError):
    """CNAME record not found or doesn't point to the expected target."""


class DomainAlreadyLinkedError(CustomDomainError):
    """Domain is already linked to this or another site."""


async def _write_configs_and_reload(
    sites_config: str, server_names_config: str
) -> None:
    NGINX_MAP_PATH.write_text(sites_config)
    CUSTOM_SERVER_NAMES_PATH.write_text(server_names_config)

    # do not run nginx -t as nocost can't read nginx conf files
    # for the same reason has to run via systemctl
    await run_cmd("sudo systemctl reload nginx")


async def _obtain_certificate(domain: str) -> None:
    await run_cmd(f"sudo certbot certonly --webroot -w {CERTBOT_WEBROOT} -d {domain}")


async def _delete_certificate(domain: str) -> None:
    await run_cmd(
        f"sudo certbot delete --cert-name {domain} --non-interactive", check=False
    )


def _is_internal_domain(hostname: str) -> bool:
    return any(hostname.endswith(f".{domain}") for domain in VARS["allowed_domains"])
