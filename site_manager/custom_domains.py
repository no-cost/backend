import asyncio
import subprocess
from pathlib import Path

import dns.resolver
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from database.models import Site
from settings import VARS

NGINX_MAP_PATH = Path("/etc/nginx/maps/sites.conf")
CNAME_TARGET = f"cname.{VARS['main_domain']}"


def check_cname(custom_domain: str) -> bool:
    """
    Check if a custom domain has a CNAME record pointing to `cname.<main_domain>`.
    """

    try:
        answers = dns.resolver.resolve(custom_domain, "CNAME")
        for rdata in answers:
            target = str(rdata.target).rstrip(".")
            if target.lower() == CNAME_TARGET.lower():
                return True
        return False
    except (
        dns.resolver.NoAnswer,
        dns.resolver.NXDOMAIN,
        dns.resolver.NoNameservers,
        dns.resolver.LifetimeTimeout,
    ):
        return False


async def link_custom_domain(db: AsyncSession, site: Site, custom_domain: str) -> None:
    """
    Link a custom domain to a site.
    """

    custom_domain = custom_domain.lower().strip()

    if site.hostname == custom_domain:
        raise DomainAlreadyLinkedError(
            f"Domain '{custom_domain}' is already linked to this site"
        )

    existing_site = await Site.get_by_hostname(db, custom_domain)
    if existing_site is not None:
        raise DomainAlreadyLinkedError(
            f"Domain '{custom_domain}' is already linked to another site"
        )

    if not check_cname(custom_domain):
        raise CNAMENotFoundError(
            f"CNAME record for '{custom_domain}' must point to '{CNAME_TARGET}'"
        )

    site.hostname = custom_domain
    await db.commit()
    await write_nginx_map(db)


async def unlink_custom_domain(
    db: AsyncSession, site: Site, restore_canonical: str
) -> None:
    """
    Unlink a custom domain from a site and restore canonical hostname.
    """

    site.hostname = restore_canonical
    await db.commit()
    await write_nginx_map(db)


async def write_nginx_map(db: AsyncSession) -> None:
    """
    Write the nginx map configuration file and reload nginx.

    This generates /etc/nginx/maps/sites.conf, see [`nocost/deploy`](https://github.com/no-cost/deploy/blob/master/playbooks/files/etc/nginx/maps/sites.conf).
    """

    sites = await Site.get_all_active(db, Site.hostname.isnot(None))

    # hostname -> site_id
    host_entries: list[str] = []
    for site in sites:
        host_entries.append(f"        {site.hostname}    {site.tag};")

    # site_id -> service_type
    type_entries: list[str] = []
    for site in sites:
        type_entries.append(f"        {site.tag}    {site.site_type};")

    config = f"""\
# auto-generated by site_manager/custom_domains.py

# hostname -> site_id
map $host $site_id {{
    hostnames;

{'\n'.join(host_entries) if host_entries else "        # no sites :o"}

    default "";
}}

# site_id -> service_type
map $site_id $service_type {{
{'\n'.join(type_entries) if type_entries else "        # no sites :o"}

    default "";
}}
"""

    await asyncio.to_thread(_write_config_and_reload, config)


def _write_config_and_reload(config: str) -> None:
    NGINX_MAP_PATH.write_text(config)

    # do not run nginx -t as nocost can't read nginx conf files
    subprocess.run(["nginx", "-s", "reload"], check=True)


class CustomDomainError(Exception):
    """Base exception for custom domain operations."""


class CNAMENotFoundError(CustomDomainError):
    """CNAME record not found or doesn't point to the expected target."""


class DomainAlreadyLinkedError(CustomDomainError):
    """Domain is already linked to this or another site."""
